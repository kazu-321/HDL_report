# 課題23-2
## コード
### matrix_key.v
```v
module m_matrix_key(
	input             clk, rst,	// クロック，リセット
	input      [3:0]  row, 			// 4bit入力 行
	output reg [3:0]  col,			// 4bit出力 列
	output reg [15:0] key,			// 16bitキー出力
	output            tc				// 出力カウント
	) ;
	
	reg [2:0]  index ;	
	reg [15:0] tmp ;

	always @(posedge rst or posedge clk) begin
		if(rst == 1'b1)begin
		   tmp   <= 16'hFFFF ;
			key   <= 16'h0000 ;
			index <= 3'd0 ;
		end
		else begin
			//LSB=0 colへの出力をセット
			if (index[0] == 1'b0) begin
				case (index[2:1]) 
					2'd0: begin
								col <= 4'b1110 ;
								key <= ~tmp ;
								tmp <= 16'hFFFF ;
							end
					2'd1: col <= 4'b1101 ;
					2'd2: col <= 4'b1011 ;
					2'd3: col <= 4'b0111 ;
				endcase
			end
			//LSB=1 rowの値を読む
			else begin
				tmp[{2'd0, index[2:1]}] <= row[0] ;
				tmp[{2'd1, index[2:1]}] <= row[1] ;
				tmp[{2'd2, index[2:1]}] <= row[2] ;
				tmp[{2'd3, index[2:1]}] <= row[3] ;
			end
			
			index <= index + 3'd1 ;		
			
		end
	end
	
	assign tc = (index == 3'd0) ? 1'b1 : 1'b0 ;
	 
endmodule

// 押下されているキーを4bitで出力（16bit→4bitデコーダ）
module m_dec16to4 (
    input [15:0] key,		// 16bit入力
    output [3:0] out,		// 4bit出力
    output       pushed		//打鍵検出
) ;

    function [4:0] f ;
        input [15:0] in ;
        case(in)
			  16'h0001: f = { 1'b1, 4'h0 } ;		// 0000_0000_0000_0001 → 4'h0
			  16'h0002: f = { 1'b1, 4'h1 } ;		// 0000_0000_0000_0010 → 4'h1
			  16'h0004: f = { 1'b1, 4'h2 } ;		// 0000_0000_0000_0100 → 4'h2
			  16'h0008: f = { 1'b1, 4'h3 } ;		// 0000_0000_0000_1000 → 4'h3
			  16'h0010: f = { 1'b1, 4'h4 } ;		// 0000_0000_0001_0000 → 4'h4
			  16'h0020: f = { 1'b1, 4'h5 } ;		// 0000_0000_0010_0000 → 4'h5
			  16'h0040: f = { 1'b1, 4'h6 } ;		// 0000_0000_0100_0000 → 4'h6
			  16'h0080: f = { 1'b1, 4'h7 } ;		// 0000_0000_1000_0000 → 4'h7
			  16'h0100: f = { 1'b1, 4'h8 } ;		// 0000_0001_0000_0000 → 4'h8
			  16'h0200: f = { 1'b1, 4'h9 } ;		// 0000_0010_0000_0000 → 4'h9
			  16'h0400: f = { 1'b1, 4'hA } ;		// 0000_0100_0000_0000 → 4'hA
			  16'h0800: f = { 1'b1, 4'hB } ;		// 0000_1000_0000_0000 → 4'hB
			  16'h1000: f = { 1'b1, 4'hC } ;		// 0001_0000_0000_0000 → 4'hC
			  16'h2000: f = { 1'b1, 4'hD } ;		// 0010_0000_0000_0000 → 4'hD
			  16'h4000: f = { 1'b1, 4'hE } ;		// 0100_0000_0000_0000 → 4'hE
			  16'h8000: f = { 1'b1, 4'hF } ;		// 1000_0000_0000_0000 → 4'hF
			  default:  f = { 1'b0, 4'h0 } ;		// キーが一つだけ押されているとき以外は pushed=0, out=0
        endcase
    endfunction

    assign { pushed, out } = f(key) ;

endmodule

module m_convert_num (
	input [3:0] key,
	output [3:0] num
);
	function [3:0] f;
		input [3:0] in;
		case(in)
			4'h0: f = 4'h1;
			4'h1: f = 4'h2;
			4'h2: f = 4'h3;
			4'h3: f = 4'hA;
            4'h4: f = 4'h4;
            4'h5: f = 4'h5;
            4'h6: f = 4'h6;
			4'h7: f = 4'hB;
			4'h8: f = 4'h7;
			4'h9: f = 4'h8;
			4'hA: f = 4'h9;
			4'hB: f = 4'hC;
			4'hD: f = 4'h0;
			4'hF: f = 4'hD;
			default: f = 4'hF;
		endcase
	endfunction
	
	assign num = f(key);
	
endmodule
```

### SevenSegment.v
```v
// 分周器(100Hz)
module m_prescale(input clk,output c_out);
	reg [19:0] cnt;
	wire wcout;
	
	assign wcout=(cnt==20'd499999) ? 1'b1 : 1'b0;
	assign c_out=wcout;
	
	always @(posedge clk) begin
		if(wcout==1'b1)
			cnt=0;
		else
			cnt=cnt+1;
	end
endmodule

// マトリクスキー用7セグLED表示
module m_mat7segment(input [3:0] idat, input pushed, output [7:0] odat);

    function [7:0] LedDec;
      input [3:0] num;
      begin
         case (num)
           4'h0:        LedDec = 8'b11000000;  // 0
           4'h1:        LedDec = 8'b11111001;  // 1
           4'h2:        LedDec = 8'b10100100;  // 2
           4'h3:        LedDec = 8'b10110000;  // 3
           4'h4:        LedDec = 8'b10011001;  // 4
           4'h5:        LedDec = 8'b10010010;  // 5
           4'h6:        LedDec = 8'b10000010;  // 6
           4'h7:        LedDec = 8'b11111000;  // 7
           4'h8:        LedDec = 8'b10000000;  // 8
           4'h9:        LedDec = 8'b10011000;  // 9
           4'ha:        LedDec = 8'b10001000;  // A
           4'hb:        LedDec = 8'b10000011;  // B
           4'hc:        LedDec = 8'b10100111;  // C
           4'hd:        LedDec = 8'b10100001;  // D
           4'he:        LedDec = 8'b10000110;  // E
           4'hf:        LedDec = 8'b10001110;  // F
           default:     LedDec = 8'b11111111;  // LED OFF
         endcase
      end 
    endfunction
	
	assign odat= (pushed) ? LedDec(idat) : 8'b11111111; //打鍵時のみ表示
	
endmodule
```

### TopModule.v
```v
module TopModule(
	//////////// CLOCK //////////
	input 		          		CLK1,
	input 		          		CLK2,
	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,
	//////////// Push Button //////////
	input 		     [1:0]		BTN,
	//////////// LED //////////
	output		     [9:0]		LED,
	//////////// SW //////////
	input 		     [9:0]		SW,
	
	//////////// Matrix Key ///////////
	input            [3:0]     KEY_ROW,
	output           [3:0]     KEY_COL

	);
	wire clk;
	wire [3:0]  wq;			//押下キー(4bit)
	wire [3:0]  num;        //
	wire [15:0] key;			//押下キー(16bit)
	wire [7:0]  dec_pat0;	//7セグ表示パターン
	wire pushed;				//打鍵検出

	
	m_prescale(CLK1, clk);	//100Hz
	
	m_matrix_key(clk, SW[0], KEY_ROW, KEY_COL, key, tc);	//マトリックスキーの打鍵検出
	
	m_dec16to4(key, wq, pushed);	// 押下キーを4bit出力
	
	m_convert_num(wq, num);
	
	m_mat7segment(num, pushed, dec_pat0);	//押下キーに応じた7セグ表示

	assign LED = {6'd0,wq};
	assign HEX0=dec_pat0;
	assign HEX1=8'hff;
	assign HEX2=8'hff;
	assign HEX3=8'hff;
	assign HEX4=8'hff;
	assign HEX5=8'hff;
	
endmodule
```





# 課題23-4
## コード
### TopModule.v
```v
module TopModule(
	//////////// CLOCK //////////
	input 		          		CLK1,
	input 		          		CLK2,
	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,
	//////////// Push Button //////////
	input 		     [1:0]		BTN,
	//////////// LED //////////
	output		     [9:0]		LED,
	//////////// SW //////////
	input 		     [9:0]		SW,
	
	//////////// Matrix Key ///////////
	input            [3:0]     KEY_ROW,
	output           [3:0]     KEY_COL

	);
	wire clk;
	wire [3:0]  wq;			//押下キー(4bit)
	wire [3:0]  num;        //
	wire [15:0] key;			//押下キー(16bit)
	reg [3:0] rdata0, rdata1, rdata2, rdata3, rdata4, rdata5;
	wire pushed;				//打鍵検出
	reg  pushed_d; 

	
	m_prescale(CLK1, clk);	//100Hz
	
	m_matrix_key(clk, SW[0], KEY_ROW, KEY_COL, key, tc);	//マトリックスキーの打鍵検出
	
	m_dec16to4(key, wq, pushed);	// 押下キーを4bit出力
	
	m_convert_num(wq, num);
	
	always @(posedge clk) begin
		 pushed_d <= pushed;
	end

	always @(posedge clk) begin
		 if (!pushed_d && pushed) begin
			  rdata5 <= rdata4;
			  rdata4 <= rdata3;
			  rdata3 <= rdata2;
			  rdata2 <= rdata1;
			  rdata1 <= rdata0;
			  rdata0 <= num;     // 最新データ
		 end
	end

	wire [7:0] dec0, dec1, dec2, dec3, dec4, dec5;

	m_7segment u0 (rdata0, dec0);
	m_7segment u1 (rdata1, dec1);
	m_7segment u2 (rdata2, dec2);
	m_7segment u3 (rdata3, dec3);
	m_7segment u4 (rdata4, dec4);
	m_7segment u5 (rdata5, dec5);


	assign LED = {6'd0,wq};
	assign HEX0 = dec0;
	assign HEX1 = dec1;
	assign HEX2 = dec2;
	assign HEX3 = dec3;
	assign HEX4 = dec4;
	assign HEX5 = dec5;

	
endmodule
```